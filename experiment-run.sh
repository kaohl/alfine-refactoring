#!/bin/env sh

# Produce 100 refactorings of specified type.

# One way to do this is to use the same seed but drop one extra
# refactoring each iteration, this way, we are guaranteed to get
# distinct refactorings because the list is deterministic and each
# opportunity occurs once. The only problem with this is that
# we do not know how many refactorings to drop if one fails which
# means that we would redo the same refactoring a number of times
# before reaching a new one. We could skip an integer multiple of
# `limit` number of refactorings though. This would pick the first
# successful refactoring in each interval of `limit` refactorings
# or fail if a refactoring can not be found within the limit.
# `limit` would have to be chosen depending on the number of
# available refactorings.

# A third way is to pick a random seed as we do below and then
# pick the first successful, terminating if limit is reached.

if [[ ! $ALFINE_HOME ]]; then
    echo Environment variable ALFINE_HOME is unset.
    exit 1
fi

# Run until we have 100 refactorings or until one does not produce any output.

for i in {0..99}
do
    # Refactor assets.

    rm    -rf experiment/workspace
    mkdir -p  experiment/workspace/assets
    cp    -r  experiment/assets/* experiment/workspace/assets

    # Note: User must set options `limit`, `type`, and additional type-related options.

    cmd="../eclipse/eclipse -data . --src assets --lib assets/lib --out output --seed $((RANDOM)) $@"

    cd experiment/workspace

    eval $cmd > output.log

    cd -

    # We assume that the refactoring framework only output new
    # archives if a refactoring was successfully applied.

    if [ ! "$(ls -A experiment/workspace/output)" ]; then
        echo "Failed to refactor project (with i=$i): No output generated by refactoring."
        break
    fi

    # Save output.

    mkdir -p experiment/output/"d$i"

    echo "$cmd" > experiment/output/d$i/cmd.txt

    cp experiment/workspace/output.log \
       experiment/output/"d$i"

    # The `ls` command will print an error for each
    # brace-expanded pattern that fails to match any
    # files. However, we still get a list of all
    # successfully matched files by remaining
    # patterns.

    archives=$(ls experiment/assets/*.{jar,zip})

    for old in $archives
    do
        filename=$(basename $old)
        new=experiment/workspace/output/$filename
        out=experiment/output/d$i/$filename.patch

        if [[ -e $new ]]; then
            $ALFINE_HOME/lib/jdiff.sh $old $new $out
        else
            echo "" > $out
        fi
    done
done
