#!/usr/bin/env bash

# Produce 100 refactorings of specified type.
#
# Note: Caller must set options `limit`, `type`, and additional
#       type-related options.
#
# Note: All seeds must match to reproduce a refactoring
#       (that's why we save the command).

if [[ ! $ALFINE_HOME ]]; then
    echo Environment variable ALFINE_HOME is unset.
    exit 1
fi

# Run until we have 100 refactorings or until one does not produce any output.

for i in {0..99}
do
    # Refactor assets.

    rm    -rf experiment/workspace
    mkdir -p  experiment/workspace/assets
    cp    -r  experiment/assets/* experiment/workspace/assets

    # Note
    #  `seed`, `shuffle`, and `select` are seeds for pseudorandom number
    #  generators. They are used for generating identifiers (rename-refactorings
    #  only), for sorting opportunities (always), and for selecting interval
    #  length in extract method refactorings, respectively. All seeds default to
    #  zero unless specified.

    # Construct command (will be executed from workspace directory!)

    seeds="--seed $((RANDOM)) --shuffle $((RANDOM)) --select $((RANDOM))"
    cmd="../eclipse/eclipse -data . --src assets --lib assets/lib --out output $seeds $@"

    # Execute command.

    cd experiment/workspace

    eval $cmd > output.log

    cd -

    # Check status (abort on failure).

    # We assume that the refactoring framework only output new
    # archives if a refactoring was successfully applied.

    if [ ! "$(ls -A experiment/workspace/output)" ]; then
        echo "Failed to refactor project (with i=$i): No output was generated by refactoring."
        echo "See \`experiment/workspace/output.log\`".
        break
    fi

    # Save command and output.

    mkdir -p experiment/output/"d$i"

    echo "$cmd" > experiment/output/d$i/cmd.txt

    # Always save `output.log` (can be quite large in size).
    # However, let the user choose whether to discard it.

    cp experiment/workspace/output.log \
       experiment/output/"d$i"

    # Generate patch files.

    # The `ls` command will print an error for each
    # brace-expanded pattern that fails to match any
    # files. However, we still get a list of all
    # successfully matched files by other patterns.

    archives=$(ls experiment/assets/*.{jar,zip})

    for old in $archives
    do
        filename=$(basename $old)
        new=experiment/workspace/output/$filename
        out=experiment/output/d$i/$filename.patch

        if [[ -e $new ]]; then
            $ALFINE_HOME/lib/jdiff.sh $old $new $out
        else
	    # Should we use `touch` instead?
            echo "" > $out
        fi
    done
done
